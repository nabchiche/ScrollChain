import random
from datetime import datetime, timedelta
from faker import Faker
import hashlib

# Configuration for Data Volume
NUM_USERS = 300
NUM_THEMES = 40  # Categories
NUM_GROUPS = 15
NUM_POSTS = 500
PROB_COHERENT_SUB = 0.85 # 85% chance a user follows someone with similar interests

# Initialize Faker
fake = Faker()

# --- Helper Functions ---
def escape_sql(text):
    """Escapes single quotes for SQL."""
    return text.replace("'", "''")

def get_random_date():
    return fake.date_time_between(start_date='-2y', end_date='now')

def generate_password_hash():
    """Simulates a 128-char hashed password"""
    return hashlib.sha512(fake.password().encode()).hexdigest()[0:128]

# --- Data Storage for Relationships ---
users = []  # List of dicts
themes = [] # List of strings
user_likings = {} # user_id -> set(tags)
posts = [] # List of dicts

# Output File
output_file = "insert_data.sql"

print(f"Generating data for {NUM_USERS} users...")

with open(output_file, "w", encoding="utf-8") as f:
    f.write("-- Synthetic Data Generation for Postgres\n")
    f.write("-- Generated by Python Script\n\n")

    # 1. Themes (Tags)
    print("Generating Themes...")
    # We create specific categories to ensure overlap
    base_topics = ['Tech', 'Art', 'Science', 'Politics', 'Health', 'Travel', 'Food', 'Music']
    for topic in base_topics:
        for i in range(1, 6): # 5 variations per topic
            themes.append(f"{topic}_{i}")
    
    # Fill remainder with random words if needed
    while len(themes) < NUM_THEMES:
        t = fake.word() + "_" + str(random.randint(1,99))
        if t not in themes: themes.append(t)
    
    for t in themes:
        f.write(f"INSERT INTO theme (tag) VALUES ('{t}');\n")
    f.write("\n")

    # 2. Users
    print("Generating Users...")
    for i in range(1, NUM_USERS + 1):
        profile = fake.simple_profile()
        u = {
            'id': i,
            'name': escape_sql(profile['name'].split(' ')[0]),
            'surname': escape_sql(profile['name'].split(' ')[-1]),
            'email': f"{i}_{profile['mail']}", # Ensure uniqueness
            'password': generate_password_hash(),
            'reg_date': get_random_date()
        }
        users.append(u)
        f.write(f"INSERT INTO user_ (name_user, email, password, register_date, surname) "
                f"VALUES ('{u['name']}', '{u['email']}', '{u['password']}', '{u['reg_date']}', '{u['surname']}');\n")
    f.write("\n")

    # 3. Likings (Crucial for the complex query)
    print("Generating Likings (forcing overlaps)...")
    # To satisfy "common_tag_count > 3", users must have 4+ tags.
    # We assign users a "persona" based on base_topics to ensure high overlap.
    for u in users:
        # Pick a primary interest category (e.g., 'Tech')
        persona = random.choice(base_topics)
        
        # Get all tags related to that persona
        persona_tags = [t for t in themes if t.startswith(persona)]
        
        # Get some random other tags
        random_tags = random.sample(themes, k=3)
        
        # Combine: User gets most of the persona tags + some random ones
        # Ensuring at least 5 tags per user
        user_tags = set(persona_tags + random_tags)
        
        user_likings[u['id']] = list(user_tags)
        
        for tag in user_tags:
            f.write(f"INSERT INTO likings (id, tag) VALUES ({u['id']}, '{tag}');\n")
    f.write("\n")

    # 4. Groups & Memberships
    print("Generating Groups...")
    groups = []
    for i in range(NUM_GROUPS):
        g_tag = random.choice(themes)
        g_name = f"Fans of {g_tag} {i}"
        groups.append({'name': g_name, 'tag': g_tag})
        f.write(f"INSERT INTO group_ (name_group, tag) VALUES ('{g_name}', '{g_tag}');\n")
    f.write("\n")

    print("Generating Memberships...")
    # Users join groups that match their likings (Coherence)
    for g in groups:
        # Find users who like the group's tag
        interested_users = [uid for uid, tags in user_likings.items() if g['tag'] in tags]
        # 50% of interested users join
        for uid in interested_users:
            if random.random() > 0.5:
                f.write(f"INSERT INTO membership (id, name_group) VALUES ({uid}, '{g['name']}');\n")
    f.write("\n")

    # 5. Posts
    print("Generating Posts...")
    post_visibility = ['Private', 'Friends', 'Subscribers', 'Public']
    for i in range(1, NUM_POSTS + 1):
        author_id = random.randint(1, NUM_USERS)
        # Author posts about something they like
        if user_likings[author_id]:
            tag = random.choice(user_likings[author_id])
        else:
            tag = random.choice(themes)
            
        p_title = escape_sql(fake.sentence(nb_words=4))
        p_content = escape_sql(fake.text(max_nb_chars=200))
        p_date = get_random_date()
        p_vis = random.choice(post_visibility)
        
        posts.append({'id': i, 'author': author_id, 'date': p_date})
        
        f.write(f"INSERT INTO post (title, content, publish_date, visibility, tag, id_author) "
                f"VALUES ('{p_title}', '{p_content}', '{p_date}', '{p_vis}', '{tag}', {author_id});\n")
    f.write("\n")

    # 6. Subscribe (Highly engineered for the complex query)
    print("Generating Subscriptions...")
    # Logic:
    # We need "same_likings_users_subscription" to have data.
    # This means User A follows User B, and User A and B share > 3 tags.
    
    unique_subs = set()
    
    for subscriber in users:
        subscriber_id = subscriber['id']
        my_tags = set(user_likings[subscriber_id])
        
        # Determine number of subscriptions (active users follow more)
        num_subs = random.randint(5, 20)
        
        targets = []
        
        # 1. Find coherent targets (people with similar tags)
        # Calculate overlap for ALL other users (expensive but necessary for quality data)
        candidates = []
        for other in users:
            if other['id'] == subscriber_id: continue
            other_tags = set(user_likings[other['id']])
            overlap = len(my_tags.intersection(other_tags))
            
            # If overlap > 3 (matching the query condition), high chance to follow
            if overlap > 3:
                candidates.append(other['id'])
        
        # Pick mostly from candidates (Coherence)
        if candidates:
            k = min(len(candidates), int(num_subs * PROB_COHERENT_SUB))
            targets.extend(random.sample(candidates, k))
            
        # Fill rest with randoms
        while len(targets) < num_subs:
            rand_id = random.randint(1, NUM_USERS)
            if rand_id != subscriber_id and rand_id not in targets:
                targets.append(rand_id)
                
        for target_id in targets:
            # Prevent duplicates
            if (target_id, subscriber_id) not in unique_subs:
                # Note: Schema says (id_subscribed, id_subscription)
                # target_id is the one BEING subscribed to.
                # subscriber_id is the one DOING the subscription.
                f.write(f"INSERT INTO subscribe (id_subscribed, id_subscription) VALUES ({target_id}, {subscriber_id});\n")
                unique_subs.add((target_id, subscriber_id))
    f.write("\n")

    # 7. Interactions
    print("Generating Interactions...")
    interaction_types = ['like', 'share', 'comment']
    used_interactions = set()
    
    for i in range(NUM_POSTS * 2): # Average 2 interactions per post
        post = random.choice(posts)
        # Interactive user is likely not the author
        actor_id = random.randint(1, NUM_USERS)
        while actor_id == post['author']:
            actor_id = random.randint(1, NUM_USERS)
            
        i_type = random.choice(interaction_types)
        # Interaction date must be after post date
        i_date = post['date'] + timedelta(minutes=random.randint(1, 10000))
        
        key = (post['id'], actor_id, i_type)
        if key not in used_interactions:
            f.write(f"INSERT INTO interaction (id_target_post, id_origin_user, type_interaction, interaction_date) "
                    f"VALUES ({post['id']}, {actor_id}, '{i_type}', '{i_date}');\n")
            used_interactions.add(key)
            
    # 8. Messages
    print("Generating Messages...")
    # Random chatter
    used_messages = set()
    for i in range(NUM_USERS * 2):
        s = random.randint(1, NUM_USERS)
        r = random.randint(1, NUM_USERS)
        if s == r: continue
        
        content = escape_sql(fake.sentence())
        d = get_random_date()
        
        # PK is (receiver, sender, date)
        key = (r, s, d)
        if key not in used_messages:
            f.write(f"INSERT INTO message (id_receiver, id_sender, content, send_date) "
                    f"VALUES ({r}, {s}, '{content}', '{d}');\n")
            used_messages.add(key)

print(f"Done! SQL script written to {output_file}")